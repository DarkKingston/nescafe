<?php
use Drupal\Core\Url;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Platformsh\ConfigReader\Config;
/**
 * @file
 * Functions to support theming.
 */

function nescafe_preprocess_links__language_block(&$lang){
    $lang['current_lang'] =  \Drupal::languageManager()->getCurrentLanguage()->getId();
}

function nescafe_preprocess_menu__header_btn(&$logged){
       //dump($logged);
      $current_user = \Drupal::currentUser();
        if ($current_user->isAnonymous()) {
          // Анонимный юзер...

           $logged['items']['menu_link_content:782f8d36-a980-4feb-95ab-0c3a0da00875']['title'] = t('Зарегистрируйся и выиграй');
        }

        if ($current_user->isAuthenticated()) {
          // Авторизованный юзер...
            $routeName = new TranslatableMarkup('view.account.page_1');
            $logged['items']['menu_link_content:782f8d36-a980-4feb-95ab-0c3a0da00875']['title'] = t('Личный кабинет');
            $logged['items']['menu_link_content:782f8d36-a980-4feb-95ab-0c3a0da00875']['url'] = Url::fromRoute($routeName->getUntranslatedString());

        }

}

/*$current_path = \Drupal::service('path.current')->getPath();*/


function nescafe_preprocess_page(&$page){
    dump($page);
}

function nescafe_preprocess_region__account(&$elem){


// Create a new config object to ease reading the Platform.sh environment variables.
// You can alternatively use getenv() yourself.
$config = new Config();

// The 'database' relationship is generally the name of primary SQL database of an application.
// That's not required, but much of our default automation code assumes it.
$credentials = $config->credentials('database');

    // Connect to the database using PDO.  If using some other abstraction layer you would
    // inject the values from $database into whatever your abstraction layer asks for.
    $dsn = sprintf('mysql:host=%s;port=%d;dbname=%s', $credentials['host'], $credentials['port'], $credentials['path']);
    $conn = new \PDO($dsn, $credentials['username'], $credentials['password'], [
        // Always use Exception error mode with PDO, as it's more reliable.
        \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
        // So we don't have to mess around with cursors and unbuffered queries by default.
        \PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => TRUE,
        // Make sure MySQL returns all matched rows on update queries including
        // rows that actually didn't have to be updated because the values didn't
        // change. This matches common behavior among other database systems.
        \PDO::MYSQL_ATTR_FOUND_ROWS => TRUE,
    ]);


    // Show table.
    $sql = "SELECT * FROM webform_submission_data WHERE name = 'user_id' AND value = 8";
    $result = $conn->query($sql);
    $result->setFetchMode(\PDO::FETCH_OBJ);

    if ($result) {
        print <<<TABLE
<table id="table8">
<thead>
<tr><th>ID</th><th>Codul Promotional</th> <th>Numarul de puncte</th></tr>
</thead>
<tbody>
TABLE;
$count = 1;
$score = 0;
        foreach ($result as $record) {
            $sql2 = "SELECT * FROM webform_submission_data WHERE sid = '".$record->sid."' AND name = 'introduceti_codul_promotional' ";
            $result2 = $conn->query($sql2);
            $result2->setFetchMode(\PDO::FETCH_OBJ);

            if ($result2) {
                foreach ($result2 as $record2) {
                if(!preg_match("/^([0-9])+$/", $record2->value)){
                    $score = 1;
                }else{
                    $score = 2;
                }
                    printf("<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n", $count, $record2->value, $score);

                        $count++;


                }
            }
        }
        print "</tbody>\n</table>\n";
    }



}
